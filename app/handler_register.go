package app

import (
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"net/http"

	"github.com/SUSE/telemetry-server/app/database"
	"github.com/SUSE/telemetry/pkg/restapi"
	"github.com/SUSE/telemetry/pkg/types"
)

func (a *App) duplicateClientCheck(ar *AppRequest, crReq *restapi.ClientRegistrationRequest) (err error) {
	// check if the supplied registration's clientId already exists, e.g. a new
	// client generated the same UUID value that an existing client is using, and
	// log a warning.
	// NOTE: risk of duplicate UUID values being generated by independent client
	// systems is low, and will be further reduced for systems registered with the
	// SCC, which will assign clientId values that are unique with respect to all
	// other registered clients at that time.
	dup := new(database.ClientsRow)
	if err = dup.SetupDB(a.OperationalDB); err != nil {
		err = fmt.Errorf("clientsRow.SetupDB() for dup check failed: %w", err)
		return
	}
	dup.InitClientId(crReq)
	if dup.ClientIdExists() {
		ar.Log.Warn(
			"Duplicate clientId value detected for registration",
			slog.Int64("id", dup.Id),
			slog.String("clientId", dup.ClientId),
			slog.String("systemUUID", dup.SystemUUID),
			slog.String("timestamp", dup.ClientTimestamp),
		)
	}

	return
}

// RegisterClient is responsible for handling client registrations
func (a *App) RegisterClient(ar *AppRequest) {
	ar.Log.Info("Processing", ar.R.Method, ar.R.URL)

	// retrieve the request body
	reqBody, err := io.ReadAll(ar.R.Body)
	if err != nil {
		ar.ErrorResponse(http.StatusBadRequest, err.Error())
		return
	}
	ar.Log.Debug("Extracted", slog.Any("body", reqBody))

	// unmarshal the request body to the request struct
	var crReq restapi.ClientRegistrationRequest
	err = json.Unmarshal(reqBody, &crReq)
	if err != nil {
		ar.ErrorResponse(http.StatusBadRequest, err.Error())
		return
	}
	// verify that clientId and timestamp are specified in registration
	if string(crReq.ClientRegistration.ClientId) == "" {
		ar.ErrorResponse(http.StatusBadRequest, "missing registration clientId")
		return
	}
	if string(crReq.ClientRegistration.Timestamp) == "" {
		ar.ErrorResponse(http.StatusBadRequest, "missing registration timestamp")
		return
	}
	ar.Log.Debug("Unmarshaled", slog.Any("crReq", &crReq))

	//
	// check validity of proposed client registration
	//

	// create a client row to check for the existence of the registration
	client := new(database.ClientsRow)
	if err = client.SetupDB(a.OperationalDB); err != nil {
		ar.Log.Error("clientsRow.SetupDB() failed", slog.String("error", err.Error()))
		ar.ErrorResponse(http.StatusInternalServerError, "failed to access DB")
		return
	}

	// init with request supplied values
	client.InitRegistration(&crReq)

	// check if the supplied registration already exists, e.g. cloned system
	if client.RegistrationExists() {
		ar.ErrorResponse(http.StatusConflict, "specified registration already exists")
		return
	}

	// check for a duplicate clientId
	if err = a.duplicateClientCheck(ar, &crReq); err != nil {
		ar.Log.Error("duplicate clientId check failed", slog.String("error", err.Error()))
		ar.ErrorResponse(http.StatusInternalServerError, "failed to access DB")
		return
	}

	//
	// register the client
	//

	// generate an authToken for the new client registration
	client.AuthToken, err = a.AuthManager.CreateToken()
	if err != nil {
		ar.ErrorResponse(http.StatusInternalServerError, "failed to create authtoken for client")
		return
	}

	// record the registration date
	client.RegistrationDate = types.Now().String()

	// insert the new client record
	err = client.Insert()
	if err != nil {
		ar.ErrorResponse(http.StatusInternalServerError, "failed to register new client")
		return
	}

	// initialise a client registration response
	crResp := restapi.ClientRegistrationResponse{
		RegistrationId:   client.Id,
		AuthToken:        client.AuthToken,
		RegistrationDate: client.RegistrationDate,
	}
	ar.Log.Debug("Response", slog.Any("crResp", crResp))

	// respond success with the client registration response
	ar.JsonResponse(http.StatusOK, crResp)
}
